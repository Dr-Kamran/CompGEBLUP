# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Fast Additive Relationship Matrix (VanRaden 2008)
#' 
#' Calculates the genomic relationship matrix using the VanRaden (2008) method.
#' Uses RcppArmadillo for optimized linear algebra operations.
#' 
#' @param G Genotype matrix (individuals x markers) coded as -1, 0, 1
#' @return Additive relationship matrix (n x n)
#' @export
calc_A_matrix_cpp <- function(G) {
    .Call(`_CompGEBLUP_calc_A_matrix_cpp`, G)
}

#' Fast Dominance Relationship Matrix (Vitezica 2013)
#' 
#' Calculates the dominance relationship matrix using Vitezica et al. (2013) method.
#' 
#' @param G Genotype matrix (individuals x markers) coded as -1, 0, 1
#' @return Dominance relationship matrix (n x n)
#' @export
calc_D_matrix_cpp <- function(G) {
    .Call(`_CompGEBLUP_calc_D_matrix_cpp`, G)
}

#' Fast Epistatic Relationship Matrix (Hadamard Product)
#' 
#' Calculates epistatic relationship matrix as element-wise product of two matrices.
#' 
#' @param A First relationship matrix
#' @param B Second relationship matrix
#' @return Epistatic relationship matrix (Hadamard product)
#' @export
calc_epistatic_matrix_cpp <- function(A, B) {
    .Call(`_CompGEBLUP_calc_epistatic_matrix_cpp`, A, B)
}

#' Eigendecomposition for EMMA-style efficient computation
#' 
#' Performs spectral decomposition of the relationship matrix for 
#' efficient variance component estimation.
#' 
#' @param K Relationship matrix (symmetric positive semi-definite)
#' @return List with eigenvectors (U) and eigenvalues (d)
#' @export
eigen_decomp_cpp <- function(K) {
    .Call(`_CompGEBLUP_eigen_decomp_cpp`, K)
}

#' Fast REML log-likelihood evaluation (EMMA-style)
#' 
#' Computes the REML log-likelihood given transformed data and lambda.
#' Uses pre-computed eigendecomposition for O(n) complexity per evaluation.
#' 
#' @param eta Transformed response (U'y where U is eigenvector matrix)
#' @param xi Transformed fixed effects (U'X)
#' @param d Eigenvalues of K matrix
#' @param lambda Ratio of residual to genetic variance (sigma2_e / sigma2_g)
#' @return REML log-likelihood value
#' @export
emma_reml_loglik_cpp <- function(eta, xi, d, lambda) {
    .Call(`_CompGEBLUP_emma_reml_loglik_cpp`, eta, xi, d, lambda)
}

#' EMMA-style variance component estimation using Brent's method
#' 
#' Efficiently estimates variance components using spectral decomposition
#' and 1D optimization over lambda = sigma2_e / sigma2_g.
#' 
#' @param y Response vector
#' @param X Fixed effects design matrix
#' @param K Relationship matrix
#' @param tol Convergence tolerance
#' @param max_iter Maximum iterations for optimization
#' @return List with sigma2_g, sigma2_e, and other parameters
#' @export
emma_reml_cpp <- function(y, X, K, tol = 1e-6, max_iter = 100L) {
    .Call(`_CompGEBLUP_emma_reml_cpp`, y, X, K, tol, max_iter)
}

#' Fast GWAS marker testing with pre-computed decomposition
#' 
#' Tests all markers efficiently using pre-computed eigendecomposition.
#' This is the core of EMMAX/GEMMA-style fast GWAS.
#' 
#' @param y Response vector
#' @param X Base fixed effects design matrix (usually just intercept)
#' @param M Marker matrix (n x m)
#' @param U Eigenvector matrix from K decomposition
#' @param d Eigenvalues from K decomposition
#' @param lambda Ratio sigma2_e/sigma2_g (from null model)
#' @return Matrix with columns: beta, se, t_stat, p_value
#' @export
gwas_emmax_cpp <- function(y, X, M, U, d, lambda) {
    .Call(`_CompGEBLUP_gwas_emmax_cpp`, y, X, M, U, d, lambda)
}

#' Sparse incidence matrix creation
#' 
#' Creates a sparse incidence (Z) matrix mapping observations to levels.
#' 
#' @param factor_idx Integer vector of factor levels (1-indexed)
#' @param n_levels Number of unique levels
#' @return Sparse matrix (dgCMatrix format)
#' @export
create_Z_sparse_cpp <- function(factor_idx, n_levels) {
    .Call(`_CompGEBLUP_create_Z_sparse_cpp`, factor_idx, n_levels)
}

#' Efficient computation of ZKZ'
#' 
#' Computes Z * K * Z' efficiently for variance component models.
#' 
#' @param Z Incidence matrix (can be sparse)
#' @param K Relationship matrix (dense)
#' @return ZKZ' matrix
#' @export
compute_ZKZt_cpp <- function(Z, K) {
    .Call(`_CompGEBLUP_compute_ZKZt_cpp`, Z, K)
}

#' Solve mixed model equations efficiently
#' 
#' Solves the Henderson's mixed model equations using efficient algorithms.
#' 
#' @param y Response vector
#' @param X Fixed effects design matrix
#' @param Z Random effects design matrix
#' @param K Relationship matrix
#' @param sigma2_g Genetic variance
#' @param sigma2_e Residual variance
#' @return List with fixed effects (b) and random effects (u)
#' @export
solve_mme_cpp <- function(y, X, Z, K, sigma2_g, sigma2_e) {
    .Call(`_CompGEBLUP_solve_mme_cpp`, y, X, Z, K, sigma2_g, sigma2_e)
}

#' Check if matrix is positive definite
#' 
#' @param M Square matrix
#' @param tol Tolerance for smallest eigenvalue
#' @return TRUE if positive definite
#' @export
is_positive_definite_cpp <- function(M, tol = 1e-8) {
    .Call(`_CompGEBLUP_is_positive_definite_cpp`, M, tol)
}

#' Make matrix positive definite by adding ridge
#' 
#' @param M Square matrix
#' @param tol Tolerance for smallest eigenvalue
#' @return Positive definite matrix
#' @export
make_pd_cpp <- function(M, tol = 1e-6) {
    .Call(`_CompGEBLUP_make_pd_cpp`, M, tol)
}

#' Fast PLINK BED File Decoding
#' 
#' Decodes PLINK binary BED format genotype data to integer matrix.
#' Uses standard PLINK BED encoding:
#' - 00 (binary) = 0 (homozygous reference)
#' - 01 (binary) = NA (missing)
#' - 10 (binary) = 1 (heterozygous)
#' - 11 (binary) = 2 (homozygous alternate)
#' 
#' @param bed_data Raw vector containing BED file bytes (after 3-byte header)
#' @param n_ind Number of individuals
#' @param n_snp Number of SNPs
#' @return Integer matrix (n_ind x n_snp) with genotypes coded as 0, 1, 2, or NA
#' @export
decode_bed_cpp <- function(bed_data, n_ind, n_snp) {
    .Call(`_CompGEBLUP_decode_bed_cpp`, bed_data, n_ind, n_snp)
}

#' Henderson's MME Solver in C++ (Single Random Effect)
#' 
#' Solves Henderson's Mixed Model Equations in (p+q)-space for maximum efficiency.
#' Much faster than observation-space methods when n >> q.
#' 
#' @param y Response vector (n x 1)
#' @param X Fixed effects design matrix (n x p)
#' @param Z Random effects design matrix (n x q)
#' @param K_inv Inverse of relationship matrix (q x q)
#' @param sigma2_g Genetic variance component
#' @param sigma2_e Residual variance component
#' @return List with fixed effects (b), random effects (u), fitted values, residuals
#' @export
solve_henderson_mme_cpp <- function(y, X, Z, K_inv, sigma2_g, sigma2_e) {
    .Call(`_CompGEBLUP_solve_henderson_mme_cpp`, y, X, Z, K_inv, sigma2_g, sigma2_e)
}

#' Henderson's MME Solver with EM-REML (C++ Version)
#' 
#' Complete Henderson's MME solver with EM-REML variance component estimation.
#' Supports single random effect for now (can be extended to multiple).
#' 
#' @param y Response vector (n x 1)
#' @param X Fixed effects design matrix (n x p)
#' @param Z Random effects design matrix (n x q)
#' @param K Relationship matrix (q x q)
#' @param sigma2_g_init Initial genetic variance
#' @param sigma2_e_init Initial residual variance
#' @param max_iter Maximum iterations
#' @param tol Convergence tolerance
#' @param verbose Print progress
#' @return List with model components including variance components
#' @export
fit_henderson_mme_cpp <- function(y, X, Z, K, sigma2_g_init = -1.0, sigma2_e_init = -1.0, max_iter = 50L, tol = 1e-4, verbose = FALSE) {
    .Call(`_CompGEBLUP_fit_henderson_mme_cpp`, y, X, Z, K, sigma2_g_init, sigma2_e_init, max_iter, tol, verbose)
}

